Объект `Comment` представляет комментарий, оставленный пользователем.

Связь между родительскими и детскими комментариями определяется через `parentId`.

Структура объекта Comment выглядит следующим образом:

[inline-code-attrs-start title = 'Структура Comment'; type = 'typescript'; isFunctional = false; inline-code-attrs-end]
[inline-code-start]
interface Comment {
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: Устанавливается в true, если механизм обнаружения спама признал комментарий спамом. **/
    aiDeterminedSpam?: boolean
    /** Показатель того, одобрен ли комментарий для отображения. Устанавливается в true при сохранении комментария, иначе он будет скрыт. **/
    approved?: boolean
    /** Аватар пользователя. **/
    avatarSrc?: string
    /** Дочерние комментарии. Не заполняется во всех сценариях. Используется, когда через API параметр asTree установлен в true. **/
    children: Comment[]
    /** Исходный текст комментария. **/
    comment: string
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: Текст комментария, распарсенный в HTML. **/
    commentHTML?: string
    /** Email автора комментария. Обязателен, если анонимные комментарии отключены. **/
    commenterEmail?: string
    /** Ссылка автора комментария (например, их блог). **/
    commenterLink?: string
    /** Имя автора комментария. Всегда обязательно. Если недоступно, установите что-то вроде "Аноним". **/
    commenterName: string
    /** Дата оставления комментария, в формате UTC epoch. **/
    date: number
    /** "Отображаемая метка" для комментария - например "Admin", "Moderator", или что-то вроде "VIP User". **/
    displayLabel?: string
    /** Домен, на котором был опубликован комментарий. **/
    domain?: string
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: Количество раз, когда комментарий был помечен флагом. **/
    flagCount?: number
    /** #хэштеги, написанные в комментарии и успешно распознанные. Вы также можете вручную добавить хэштеги для поиска, но они не будут автоматически отображаться в тексте комментария. **/
    hashTags?: CommentHashTag[]
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: Содержит ли комментарий изображения? **/
    hasImages?: boolean
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: Содержит ли комментарий ссылки? **/
    hasLinks?: boolean
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: Уникальный идентификатор комментария. **/
    id: string
    /** Только при создании! Для хранения это хешируется. **/
    ip?: string
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: Заблокировал ли текущий пользователь автора этого комментария? **/
    isBlocked?: boolean
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: Является ли комментарий написанным администратором? Устанавливается автоматически на основе userId. **/
    isByAdmin?: boolean
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: Является ли комментарий написанным модератором? Устанавливается автоматически на основе userId. **/
    isByModerator?: boolean
    /** Устанавливается в true, если комментарий был мягко удалён (пришлось оставить заполнитель из-за другой конфигурации). **/
    isDeleted?: boolean
    /** Устанавливается в true, если аккаунт пользователя был удалён, а комментарий нужно было сохранить. **/
    isDeletedUser?: boolean
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: Был ли комментарий помечен текущим вошедшим пользователем (contextUserId)? **/
    isFlagged?: boolean
    /** Закреплён ли комментарий? **/
    isPinned?: boolean
    /** Заблокирован ли комментарий для новых ответов (модераторы по-прежнему могут отвечать)? **/
    isLocked?: boolean
    /** Является ли комментарий спамом? **/
    isSpam?: boolean
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: Проголосовал ли текущий пользователь (contextUserId) против комментария? **/
    isVotedDown?: boolean
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: Проголосовал ли текущий пользователь (contextUserId) за комментарий? **/
    isVotedUp?: boolean
    /** Локаль, в которой написан комментарий. Если не указана, будет определена по заголовку HTTP Accept-Language. **/
    locale?: 'de_de' | 'en_us' | 'es_es' | 'fr_fr' | 'it_it' | 'ja_jp' | 'ko_kr' | 'pl_pl' | 'pt_br' | 'ru_ru' | 'tr_tr' | 'zh_cn' | 'zh_tw'
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: @упоминания, написанные в комментарии и успешно распарсенные. **/
    mentions?: CommentUserMention[]
    /** Необязательные метаданные, связанные с комментарием. **/
    meta?: Record<string, string | number | boolean>
    /** Необязательный список идентификаторов групп модерации, связанных с этим комментарием. **/
    moderationGroupIds?: string[]|null
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: Идентификатор объекта голоса, соответствующий голосу текущего пользователя (contextUserId) по этому комментарию. **/
    myVoteId?: string
    /** Были ли отправлены уведомления об этом комментарии авторам. Чтобы предотвратить отправку уведомлений при импорте, установите в true. **/
    notificationSentForParent?: boolean
    /** Были ли отправлены уведомления об этом комментарии пользователям арендатора (tenant users). Чтобы предотвратить отправку уведомлений при импорте, установите в true. **/
    notificationSentForParentTenant?: boolean
    /** Заголовок страницы, на которой был оставлен комментарий. **/
    pageTitle?: string
    /** Если мы отвечаем на комментарий, это ID комментария, на который даётся ответ. **/
    parentId?: string|null
    /** Помечен ли комментарий как просмотренный. **/
    reviewed: boolean
    /** Идентификатор тенанта, к которому принадлежит комментарий. **/
    tenantId: string
    /** Пользователь, написавший комментарий. Создаётся автоматически при сохранении комментария с именем/email. **/
    userId?: string|null
    /** URL страницы, на которой виден этот комментарий, например запись в блоге. **/
    url: string
    /** "Очищенная" версия urlId, который вы передали. При сохранении вы указываете это поле, но при получении комментария оно будет "очищено", а ваше исходное значение перемещено в "urlIdRaw". **/
    urlId: string
    /** ТОЛЬКО ДЛЯ ЧТЕНИЯ: Исходный urlId, который вы передали. **/
    urlIdRaw?: string
    /** Подтверждены ли пользователь и этот комментарий? **/
    verified: boolean
    /** Количество голосов «за». **/
    votesUp?: number
    /** Количество голосов «против». **/
    votesDown?: number
    /** "Карма" комментария (= голоса за - голоса против). **/
    votes?: number
}
[inline-code-end]

Некоторые из этих полей помечены как `READONLY` - они возвращаются API, но не могут быть установлены.

### Структура текста комментария

Комментарии пишутся в собственной версии markdown от FastComments, которая представляет собой markdown с дополнительными `bbcode`-подобными тегами для изображений, например `[img]path[/img]`.

Текст хранится в двух полях. Текст, введённый пользователем, хранится без изменений в поле `comment`. Он рендерится и сохраняется в поле `commentHTML`.

Разрешённые HTML-теги: `b, u, i, strike, pre, span, code, img, a, strong, ul, ol, li, and br`.

Рекомендуется рендерить HTML, так как это очень небольшой поднабор HTML, и создать рендерер достаточно просто. Существуют различные библиотеки, например для React Native и Flutter, которые могут в этом помочь.

Вы можете выбрать рендеринг ненормализованного значения из поля `comment`. [Пример парсера находится здесь.](https://github.com/FastComments/fastcomments-code-examples/blob/master/custom-client/client/parse-comment.js).

Примерный парсер также можно настроить для работы с HTML и преобразования HTML-тегов в ожидаемые элементы для рендеринга на вашей платформе. 

### Тегирование

Когда пользователи упоминаются в комментарии, информация сохраняется в списке под названием `mentions`. Каждый объект в этом списке имеет следующую структуру.

[inline-code-attrs-start title = 'Объект упоминаний комментария'; type = 'typescript'; inline-code-attrs-end]
[inline-code-start]
interface CommentUserMention {
    /** Идентификатор пользователя. Для SSO-пользователей будет с префиксом вашего tenant id. **/
    id: string
    /** Финальный текст @упоминания, включая символ @. **/
    tag: string
    /** Оригинальный текст @упоминания, включая символ @. **/
    rawTag: string
    /** Тип отмеченного пользователя. user = аккаунт FastComments.com. sso = SSOUser. **/
    type: 'user'|'sso'
    /** Если пользователь отказался от уведомлений, это поле всё равно будет установлено в true. **/
    sent: boolean
}
[inline-code-end]

### Хэштеги

Когда хэштеги используются и успешно распарсены, информация сохраняется в списке под названием `hashTags`. Каждый объект в этом списке имеет следующую структуру. Хэштеги также можно вручную добавить в массив `hashTags` комментария для поиска, если задано `retain`.

[inline-code-attrs-start title = 'Объект хэштега комментария'; type = 'typescript'; inline-code-attrs-end]
[inline-code-start]
interface CommentHashTag {
    /** Идентификатор хэштега. **/
    id: string
    /** Финальный текст #хэштега, включая символ #. **/
    tag: string
    /** Если хэштег связан с пользовательским URL, это будет задано. **/
    url?: string
    /** Следует ли сохранять хэштег, даже если он не присутствует в тексте комментария при его обновлении. Полезно для пометки комментариев без изменения текста. **/
    retain?: boolean
}
[inline-code-end]

---