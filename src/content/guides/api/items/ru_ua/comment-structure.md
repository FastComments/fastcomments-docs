Объект `Comment` представляет комментарий, оставленный пользователем.

Связь между родительскими и дочерними комментариями определяется через `parentId`.

Структура объекта Comment выглядит следующим образом:

[inline-code-attrs-start title = 'Структура объекта Comment'; type = 'typescript'; isFunctional = false; inline-code-attrs-end]
[inline-code-start]
interface Comment {
    /** READONLY: Установлено в true, если система обнаружения спама определила комментарий как спам. **/
    aiDeterminedSpam?: boolean
    /** Показывается ли комментарий. При сохранении комментария устанавливается в true, иначе он будет скрыт. **/
    approved?: boolean
    /** Аватар пользователя. **/
    avatarSrc?: string
    /** Дочерние комментарии. Не заполняется во всех сценариях. Используется, когда через API параметр asTree установлен в true. **/
    children: Comment[]
    /** Оригинальный текст комментария от пользователя. **/
    comment: string
    /** READONLY: Текст комментария, преобразованный в HTML. **/
    commentHTML?: string
    /** Email комментатора. Обязателен, если анонимные комментарии отключены. **/
    commenterEmail?: string
    /** Ссылка комментатора (например, его блог). **/
    commenterLink?: string
    /** Имя комментатора. Всегда обязательно. Если недоступно, установите что-то вроде "Anonymous". **/
    commenterName: string
    /** Дата оставления комментария в виде UTC epoch. **/
    date: number
    /** "Отображаемая метка" для комментария - например "Admin", "Moderator", или что-то вроде "VIP User". **/
    displayLabel?: string
    /** Домен, на котором был опубликован комментарий. **/
    domain?: string
    /** READONLY: Количество пометок (флагов) для комментария. **/
    flagCount?: number
    /** #хэштеги, написанные в комментарии и успешно распарсенные. Также вы можете вручную добавить хэштеги для запроса, но они не будут автоматически отображаться в тексте комментария. **/
    hashTags?: CommentHashTag[]
    /** READONLY: Содержит ли комментарий изображения? **/
    hasImages?: boolean
    /** READONLY: Содержит ли комментарий ссылки? **/
    hasLinks?: boolean
    /** READONLY: Уникальный идентификатор комментария. **/
    id: string
    /** Только при создании! Для хранения значение хешируется. **/
    ip?: string
    /** READONLY: Заблокировал ли текущий пользователь автора этого комментария? **/
    isBlocked?: boolean
    /** READONLY: Автор комментария — администратор? Автоматически определяется по userId. **/
    isByAdmin?: boolean
    /** READONLY: Автор комментария — модератор? Автоматически определяется по userId. **/
    isByModerator?: boolean
    /** Установлено в true, если комментарий был мягко удалён (оставлен заполнитель из-за другой конфигурации). **/
    isDeleted?: boolean
    /** Установлено в true, если аккаунт пользователя был удалён, а комментарий нужно было сохранить. **/
    isDeletedUser?: boolean
    /** READONLY: Отмечен ли комментарий флагом текущего вошедшего пользователя (contextUserId)? **/
    isFlagged?: boolean
    /** Закреплен ли комментарий? **/
    isPinned?: boolean
    /** Заблокирован ли комментарий для новых ответов (модераторы всё ещё могут отвечать)? **/
    isLocked?: boolean
    /** Является ли комментарий спамом? **/
    isSpam?: boolean
    /** READONLY: Проголосовал ли текущий пользователь (contextUserId) против комментария? **/
    isVotedDown?: boolean
    /** READONLY: Проголосовал ли текущий пользователь (contextUserId) за комментарий? **/
    isVotedUp?: boolean
    /** Локаль, на которой написан комментарий. Если не указана, будет определена по HTTP-заголовку Accept-Language. **/
    locale?: 'de_de' | 'en_us' | 'es_es' | 'fr_fr' | 'it_it' | 'ja_jp' | 'ko_kr' | 'pl_pl' | 'pt_br' | 'ru_ru' | 'tr_tr' | 'zh_cn' | 'zh_tw'
    /** READONLY: @упоминания, написанные в комментарии и успешно распарсенные. **/
    mentions?: CommentUserMention[]
    /** Дополнительные метаданные, связанные с комментарием. **/
    meta?: Record<string, string | number | boolean>
    /** Необязательный список идентификаторов групп модерации, связанных с этим комментарием. **/
    moderationGroupIds?: string[]|null
    /** READONLY: Идентификатор объекта голосования, соответствующего голосу текущего пользователя (contextUserId) для этого комментария. **/
    myVoteId?: string
    /** Были ли отправлены уведомления об этом комментарии комментаторам. Чтобы предотвратить отправку уведомлений при импорте, установите это в true. **/
    notificationSentForParent?: boolean
    /** Были ли отправлены уведомления об этом комментарии пользователям тенанта. Чтобы предотвратить отправку уведомлений при импорте, установите это в true. **/
    notificationSentForParentTenant?: boolean
    /** Заголовок страницы, на которой был этот комментарий. **/
    pageTitle?: string
    /** Если мы отвечаем на комментарий, это ID комментария, на который дается ответ. **/
    parentId?: string|null
    /** Отмечен ли комментарий как просмотренный. **/
    reviewed: boolean
    /** Идентификатор тенанта, к которому принадлежит комментарий. **/
    tenantId: string
    /** Пользователь, написавший комментарий. Создаётся автоматически при сохранении комментария с указанием имени/email. **/
    userId?: string|null
    /** URL страницы, где виден этот комментарий, например публикация в блоге. **/
    url: string
    /** "Очищенная" версия urlId, которую вы передали. При сохранении вы указываете это поле, но при получении комментария обратно оно будет "очищено" и ваше исходное значение перемещено в "urlIdRaw". **/
    urlId: string
    /** READONLY: Оригинальный urlId, который вы передали. **/
    urlIdRaw?: string
    /** Проверены ли пользователь и этот комментарий? **/
    verified: boolean
    /** Количество голосов "за". **/
    votesUp?: number
    /** Количество голосов "против". **/
    votesDown?: number
    /** "Карма" комментария (= votes up - votes down). **/
    votes?: number
}
[inline-code-end]

Некоторые из этих полей помечены как `READONLY` — они возвращаются API, но не могут быть установлены.

### Структура текста комментария

Комментарии пишутся в варианте markdown от FastComments, который представляет собой markdown плюс традиционные bbcode-подобные теги для изображений, например `[img]path[/img]`.

Текст хранится в двух полях. Текст, введённый пользователем, сохраняется без изменений в поле `comment`. Он рендерится и сохраняется в поле `commentHTML`.

Разрешённые HTML-теги: `b, u, i, strike, pre, span, code, img, a, strong, ul, ol, li, and br`.

Рекомендуется рендерить HTML, так как это очень небольшой поднабор HTML, и создание рендерера довольно простое. Существуют несколько библиотек, например для React Native и Flutter, которые могут в этом помочь

Вы можете выбрать отображение ненормализованного значения из поля `comment`. [Пример парсера находится здесь.](https://github.com/FastComments/fastcomments-code-examples/blob/master/custom-client/client/parse-comment.js).

Примерный парсер также можно настроить для работы с HTML и преобразования HTML-тегов в ожидаемые элементы для рендера в вашей платформе.

### Упоминания

Когда пользователи отмечаются в комментарии, информация сохраняется в списке `mentions`. Каждый объект в этом списке имеет следующую структуру.

[inline-code-attrs-start title = 'Объект упоминания в комментарии'; type = 'typescript'; inline-code-attrs-end]
[inline-code-start]
interface CommentUserMention {
    /** Идентификатор пользователя. Для SSO-пользователей будет добавлен префикс вашего tenant id. **/
    id: string
    /** Финальный текст @упоминания, включая символ @. **/
    tag: string
    /** Оригинальный текст @упоминания, включая символ @. **/
    rawTag: string
    /** Тип отмеченного пользователя. user = аккаунт FastComments.com. sso = SSOUser. **/
    type: 'user'|'sso'
    /** Даже если пользователь отказался от уведомлений, это поле всё равно будет true. **/
    sent: boolean
}
[inline-code-end]

### Хэштеги

Когда хэштеги используются и успешно распарсены, информация хранится в списке `hashTags`. Каждый объект в этом списке имеет следующую структуру. Хэштеги также можно вручную добавить в массив `hashTags` комментария для запросов, если установлен флаг `retain`.

[inline-code-attrs-start title = 'Объект хэштега комментария'; type = 'typescript'; inline-code-attrs-end]
[inline-code-start]
interface CommentHashTag {
    /** Идентификатор хэштега. **/
    id: string
    /** Финальный текст #хэштега, включая символ #. **/
    tag: string
    /** Если хэштег связан с кастомным URL, это будет указано. **/
    url?: string
    /** Флаг, указывающий, нужно ли сохранять хэштег, даже если он отсутствует в тексте комментария при его обновлении. Полезно для пометки комментариев без изменения текста. **/
    retain?: boolean
}
[inline-code-end]

---